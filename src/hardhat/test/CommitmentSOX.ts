import { expect } from "chai";
import { ethers } from "hardhat";
import { TestCommitmentOpener } from "../typechain-types";
import { initSync, commit } from "../../app/lib/circuits/wasm/circuits";
import { readFile } from "node:fs/promises";
import { randomBytes } from "node:crypto";

before(async () => {
    const module = await readFile(
        "../../app/lib/circuits/wasm/circuits_bg.wasm"
    );
    initSync({ module: module });
});

describe("TestCommitmentOpener with linked CommitmentOpener library", function () {
    let testContract: TestCommitmentOpener;

    beforeEach(async () => {
        // Deploy the library first
        const LibFactory = await ethers.getContractFactory("CommitmentOpener");
        const lib = await LibFactory.deploy();
        await lib.waitForDeployment();

        // Link the library when deploying the contract
        const ContractFactory = await ethers.getContractFactory(
            "TestCommitmentOpener",
            {
                libraries: {
                    CommitmentOpener: await lib.getAddress(),
                },
            }
        );

        testContract = await ContractFactory.deploy();
        await testContract.waitForDeployment();
    });

    it("should return the correct opening value prefix if commitment matches", async () => {
        const data = ethers.toUtf8Bytes("secret-data-1234567890123456"); // 16-byte suffix
        const commitment = ethers.keccak256(data);

        const result = await testContract.open(commitment, data);
        const expected =
            "0x" + Buffer.from(data.slice(0, data.length - 16)).toString("hex");

        expect(result).to.equal(expected);
    });

    it("should revert if the commitment does not match", async () => {
        const correctData = ethers.toUtf8Bytes("correct-data-1234567890123456");
        const wrongData = ethers.toUtf8Bytes("wrong-data-1234567890123456");
        const commitment = ethers.keccak256(correctData);

        await expect(
            testContract.open(commitment, wrongData)
        ).to.be.revertedWith("Commitment and opening value do not match");
    });

    it("should return empty if opening value is exactly 16 bytes", async () => {
        const data = ethers.toUtf8Bytes("1234567890abcdef"); // exactly 16 bytes
        const commitment = ethers.keccak256(data);

        const result = await testContract.open(commitment, data);
        expect(result).to.equal("0x");
    });

    it("should revert if opening value is shorter than 16 bytes", async () => {
        const data = ethers.toUtf8Bytes("short-value"); // < 16 bytes
        const commitment = ethers.keccak256(data);

        await expect(testContract.open(commitment, data)).to.be.reverted;
    });

    it("should return the correct opening value when commitment is generated by the wasm library on random data", async () => {
        const data = randomBytes(512); // 512 bytes
        const { c: commitment, o: openingValue } = commit(data);

        const result = await testContract.open(commitment, openingValue);
        const expected = "0x" + Buffer.from(data).toString("hex");

        expect(result).to.equal(expected);
    });
});
